<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基于Kruskal算法的最小生成树可视化界面</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            padding: 20px;
            margin-top: 20px;
        }
        .graph-container {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .control-panel {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .node {
            fill: #4a6fdc;
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .node:hover {
            fill: #2c4aa0;
            r: 10;
        }
        .node.selected {
            fill: #ff6b6b;
        }
        .edge {
            stroke: #ccc;
            stroke-width: 2px;
            fill: none;
        }
        .edge.selected {
            stroke: #ff6b6b;
            stroke-width: 3px;
        }
        .edge.considering {
            stroke: #ffd166;
            stroke-width: 3px;
            stroke-dasharray: 5,5;
            animation: dash 0.5s linear infinite;
        }
        .edge-label {
            font-size: 12px;
            text-anchor: middle;
            fill: #333;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
        }
        .progress-container {
            margin: 15px 0;
        }
        .stats-panel {
            background-color: #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        .stat-item {
            margin-bottom: 10px;
        }
        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }
        .btn-group .btn {
            margin-right: 5px;
        }
        .speed-control {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        .speed-control label {
            margin-right: 10px;
        }
        .legend {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }
        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center mb-4">基于Kruskal算法的最小攻击代价计算</h1>

        <div class="control-panel">
            <div class="row">
                <div class="col-md-8">
                    <div class="btn-group" role="group">
                        <button id="startBtn" class="btn btn-success">开始</button>
                        <button id="pauseBtn" class="btn btn-warning" disabled>暂停</button>
                        <button id="resetBtn" class="btn btn-danger">重置</button>
                        <button id="stepBtn" class="btn btn-info">单步</button>
                    </div>

                    <div class="speed-control">
                        <label for="speedSlider">动画速度:</label>
                        <input type="range" id="speedSlider" class="form-range" min="100" max="2000" value="1000" step="100">
                        <span id="speedValue">1000ms</span>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="showEdgeCosts" checked>
                        <label class="form-check-label" for="showEdgeCosts">显示边权值</label>
                    </div>
                </div>
            </div>

            <div class="progress-container">
                <div class="progress">
                    <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #ccc;"></div>
                <span>未选中边</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #ffd166;"></div>
                <span>考虑中边</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #ff6b6b;"></div>
                <span>已选中边</span>
            </div>
        </div>

        <div class="graph-container">
            <svg id="graph" width="100%" height="600"></svg>
        </div>

        <div class="stats-panel">
            <h4>统计信息</h4>
            <div class="row">
                <div class="col-md-4">
                    <div class="stat-item">
                        <strong>节点数量:</strong> <span id="nodeCount">0</span>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stat-item">
                        <strong>边数量:</strong> <span id="edgeCount">0</span>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stat-item">
                        <strong>当前步骤:</strong> <span id="currentStep">0</span> / <span id="totalSteps">0</span>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col-md-6">
                    <div class="stat-item">
                        <strong>已选择边数:</strong> <span id="selectedEdges">0</span>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="stat-item">
                        <strong>当前总权值:</strong> <span id="totalCost">0</span>
                    </div>
                </div>
            </div>
            <div class="row mt-3">
                <div class="col-12">
                    <div class="alert alert-info" role="alert">
                        <strong>当前操作:</strong> <span id="currentAction">等待开始</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip"></div>

    <script>
        // 全局变量
        let graphData = null;
        let processSteps = null;
        let currentStepIndex = 0;
        let isPlaying = false;
        let animationTimer = null;
        let selectedEdges = new Set();
        let simulation = null;

        // DOM元素
        const svg = d3.select("#graph");
        const tooltip = d3.select(".tooltip");
        const startBtn = document.getElementById("startBtn");
        const pauseBtn = document.getElementById("pauseBtn");
        const resetBtn = document.getElementById("resetBtn");
        const stepBtn = document.getElementById("stepBtn");
        const speedSlider = document.getElementById("speedSlider");
        const speedValue = document.getElementById("speedValue");
        const showEdgeCosts = document.getElementById("showEdgeCosts");
        const progressBar = document.getElementById("progressBar");

        // 初始化
        document.addEventListener("DOMContentLoaded", function() {
            // 设置SVG尺寸
            const containerWidth = document.querySelector(".graph-container").clientWidth;
            svg.attr("viewBox", `0 0 ${containerWidth} 600`);

            // 加载数据
            loadData();

            // 绑定事件
            startBtn.addEventListener("click", startAnimation);
            pauseBtn.addEventListener("click", pauseAnimation);
            resetBtn.addEventListener("click", resetAnimation);
            stepBtn.addEventListener("click", stepForward);
            speedSlider.addEventListener("input", function() {
                speedValue.textContent = this.value + "ms";
                if (isPlaying) {
                    pauseAnimation();
                    startAnimation();
                }
            });
            showEdgeCosts.addEventListener("change", function() {
                d3.selectAll(".edge-label").style("display", this.checked ? "block" : "none");
            });
        });

        // 加载数据
        function loadData() {
            // 加载图数据
            d3.json("graph.json").then(function(data) {
                graphData = data;

                // 加载过程数据
                d3.json("process.json").then(function(steps) {
                    processSteps = steps;

                    // 初始化可视化
                    initVisualization();
                    updateStats();
                }).catch(function(error) {
                    console.error("加载过程数据失败:", error);
                    // 如果过程数据不存在，创建一个空的过程
                    processSteps = { "steps": [] };
                    initVisualization();
                    updateStats();
                });
            }).catch(function(error) {
                console.error("加载图数据失败:", error);
                // 使用示例数据
                graphData = {
                    "nodes": [0, 1, 2, 3, 4],
                    "edges": [
                        {"from": 0, "to": 1, "cost": 2},
                        {"from": 1, "to": 2, "cost": 3},
                        {"from": 2, "to": 3, "cost": 1},
                        {"from": 2, "to": 4, "cost": 4},
                        {"from": 1, "to": 3, "cost": 6}
                    ]
                };

                // 创建示例过程数据
                processSteps = {
                    "steps": [
                        {"from": 2, "to": 3, "cost": 1},
                        {"from": 0, "to": 1, "cost": 2},
                        {"from": 1, "to": 2, "cost": 3},
                        {"from": 2, "to": 4, "cost": 4}
                    ]
                };

                initVisualization();
                updateStats();
            });
        }

        // 初始化可视化
        function initVisualization() {
            if (!graphData) return;

            // 清除现有内容
            svg.selectAll("*").remove();

            // 创建力导向图模拟
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(150))  // 增加边之间的距离
                .force("charge", d3.forceManyBody().strength(-500))         // 增加节点之间的排斥力
                .force("center", d3.forceCenter(svg.node().getBoundingClientRect().width / 2, 300))
                .force("collision", d3.forceCollide().radius(30))          // 增加节点碰撞半径

            // 创建箭头标记
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "-0 -5 10 10")
                .attr("refX", 20)
                .attr("refY", 0)
                .attr("orient", "auto")
                .attr("markerWidth", 8)
                .attr("markerHeight", 8)
                .append("svg:path")
                .attr("d", "M 0,-5 L 10,0 L 0,5")
                .attr("fill", "#999");

            // 创建边组
            const linkGroup = svg.append("g").attr("class", "links");

            // 创建节点组
            const nodeGroup = svg.append("g").attr("class", "nodes");

            // 准备节点数据
            const nodes = graphData.nodes.map(d => ({ id: d }));

            // 准备边数据
            const links = graphData.edges.map(d => ({
                source: d.from,
                target: d.to,
                cost: d.cost,
                id: `${d.from}-${d.to}`
            }));

            // 创建边
            const link = linkGroup.selectAll(".edge")
                .data(links)
                .enter().append("line")
                .attr("class", "edge")
                .attr("id", d => `edge-${d.id}`);

            // 创建边标签
            const linkLabel = linkGroup.selectAll(".edge-label")
                .data(links)
                .enter().append("text")
                .attr("class", "edge-label")
                .text(d => d.cost);

            // 创建节点
            const node = nodeGroup.selectAll(".node")
                .data(nodes)
                .enter().append("circle")
                .attr("class", "node")
                .attr("id", d => `node-${d.id}`)
                .attr("r", 8)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`节点: ${d.id}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // 创建节点标签
            const nodeLabel = nodeGroup.selectAll(".node-label")
                .data(nodes)
                .enter().append("text")
                .attr("class", "node-label")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .text(d => d.id)
                .style("pointer-events", "none")
                .style("fill", "white");

            // 更新力导向图
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                linkLabel
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                nodeLabel
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            // 更新统计信息
            updateStats();
        }

        // 拖拽功能
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 更新统计信息
        function updateStats() {
            if (!graphData) return;

            document.getElementById("nodeCount").textContent = graphData.nodes.length;
            document.getElementById("edgeCount").textContent = graphData.edges.length;
            document.getElementById("totalSteps").textContent = processSteps.steps.length;
            document.getElementById("currentStep").textContent = currentStepIndex;
            document.getElementById("selectedEdges").textContent = selectedEdges.size;

            // 计算当前总权值
            let totalCost = 0;
            selectedEdges.forEach(edgeId => {
                const [from, to] = edgeId.split('-').map(Number);
                const edge = graphData.edges.find(e => 
                    (e.from === from && e.to === to) || (e.from === to && e.to === from)
                );
                if (edge) totalCost += edge.cost;
            });
            document.getElementById("totalCost").textContent = totalCost;

            // 更新进度条
            const progress = processSteps.steps.length > 0 ? 
                (currentStepIndex / processSteps.steps.length) * 100 : 0;
            progressBar.style.width = progress + "%";
            progressBar.setAttribute("aria-valuenow", progress);
            progressBar.textContent = Math.round(progress) + "%";
        }

        // 开始动画
        function startAnimation() {
            if (!processSteps || processSteps.steps.length === 0) return;

            isPlaying = true;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            stepBtn.disabled = true;

            document.getElementById("currentAction").textContent = "正在运行Kruskal算法...";

            // 如果已经完成，重置并重新开始
            if (currentStepIndex >= processSteps.steps.length) {
                resetAnimation();
            }

            // 设置定时器
            const speed = parseInt(speedSlider.value);
            animationTimer = setInterval(() => {
                if (currentStepIndex < processSteps.steps.length) {
                    stepForward();
                } else {
                    pauseAnimation();
                    document.getElementById("currentAction").textContent = "算法执行完成！";
                }
            }, speed);
        }

        // 暂停动画
        function pauseAnimation() {
            isPlaying = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            stepBtn.disabled = false;

            if (animationTimer) {
                clearInterval(animationTimer);
                animationTimer = null;
            }

            if (currentStepIndex < processSteps.steps.length) {
                document.getElementById("currentAction").textContent = "算法已暂停";
            }
        }

        // 重置动画
        function resetAnimation() {
            pauseAnimation();

            currentStepIndex = 0;
            selectedEdges.clear();

            // 重置所有边的样式
            d3.selectAll(".edge").classed("selected", false).classed("considering", false);

            updateStats();
            document.getElementById("currentAction").textContent = "等待开始";
        }

        // 单步执行
        function stepForward() {
            if (!processSteps || processSteps.steps.length === 0) return;

            if (currentStepIndex >= processSteps.steps.length) {
                document.getElementById("currentAction").textContent = "算法执行完成！";
                return;
            }

            // 获取当前步骤的边
            const step = processSteps.steps[currentStepIndex];
            const edgeId = `${step.from}-${step.to}`;

            // 检查反向边
            const reverseEdgeId = `${step.to}-${step.from}`;
            const actualEdgeId = document.getElementById(`edge-${edgeId}`) ? edgeId : reverseEdgeId;

            // 高亮考虑中的边
            d3.selectAll(".edge").classed("considering", false);
            d3.select(`#edge-${actualEdgeId}`).classed("considering", true);

            // 更新当前操作描述
            document.getElementById("currentAction").textContent = 
                `考虑边 ${step.from} → ${step.to}，权值为 ${step.cost}`;

            // 延迟后选择边
            setTimeout(() => {
                // 只有当边被选中时才标记为selected
                if (step.selected) {
                    d3.select(`#edge-${actualEdgeId}`).classed("considering", false).classed("selected", true);
                    selectedEdges.add(actualEdgeId);
                } else {
                    d3.select(`#edge-${actualEdgeId}`).classed("considering", false);
                }

                // 更新当前步骤
                currentStepIndex++;

                // 更新统计信息
                updateStats();

                // 如果不是在播放模式，更新操作描述
                if (!isPlaying) {
                    if (currentStepIndex < processSteps.steps.length) {
                        document.getElementById("currentAction").textContent = "等待下一步";
                    } else {
                        document.getElementById("currentAction").textContent = "算法执行完成！";
                    }
                }
            }, isPlaying ? 0 : 500); // 如果不是播放模式，延迟500ms以便用户看清
        }
    </script>
</body>
</html>